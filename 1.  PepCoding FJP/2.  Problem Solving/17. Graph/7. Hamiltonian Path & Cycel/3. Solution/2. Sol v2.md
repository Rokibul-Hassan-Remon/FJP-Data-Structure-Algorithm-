# **Hamiltonian Path & Cycle DFS – Optimization Note**

### **1️⃣ Current Problem with `IsAllNodeVisited()`**

তোমার current DFS call এ:
```java
if(IsAllNodeVisited(isVisited) == true)

```

- প্রতি recursion এ **পুরো array traverse হয়** → O(n) time per recursion.
    
- Graph-এর vertices বড় হলে, এই check **ক্লিনে performance degrade করে**।
---
### **2️⃣ Optimization Idea**

- আমরা চাইতে পারি **extra parameter `count` বা `visitedCount` যোগ করতে**।
    
- এই `count` ঠিক রাখবে **কতটি node already visited**।
    
- Base case check হবে **`count == totalVertices`**, তাই আর **পুরো array traverse করার দরকার নেই**।
    

✅ Result:

- Base case check becomes **O(1) instead of O(n)**
    
- DFS আরো clean, fast
    

---

### **3️⃣ Optimized DFS Signature**
```java
public static void HamiltonPath(ArrayList<Edge>[] adjacencyList, boolean[] isVisited, int src,int cur, String path,int visitedCount ){
    // base case
    if(visitedCount == adjacencyList.length) {
        // Hamiltonian Cycle check
        for(var each : adjacencyList[cur]){
            if(src == each.neighbour){
                HamiltonianCycle++;
                Print("Hamiltonian Cycle: "+ path);
                return;
            }
        }
        HamiltonianPath++;
        Print("Hamiltonian Path: "+ path);
        return;
    }

    // DFS recursion
    for(var each : adjacencyList[cur]){
        if(!isVisited[each.neighbour]){
            isVisited[each.neighbour] = true;
            HamiltonPath(adjacencyList, isVisited, src, each.neighbour, path+" "+each.neighbour, visitedCount+1);
            isVisited[each.neighbour] = false;
        }
    }
}

```

# Full code:
```java title:"Hamiltonian Path and Cycle"
public class Edge {  
    int source;  
    int neighbour;  
    int weight;  
  
    public Edge(int source, int neighbour, int weight){  
        this.source = source;  
        this.neighbour = neighbour;  
        this.weight = weight;  
    }  
}

public class Main {  
	public static int HamiltonianPath = 0;  
	public static int HamiltonianCycle = 0;  
	  
	public static boolean IsAllNodeVisited(boolean[] isVisited){  
	    for(boolean node : isVisited){  
	        if(node == false){  
	            return false;  
	        }  
	    }  
	  
	    return  true;  
	}  
	
	public static void HamiltonPath(ArrayList<Edge>[] adjacencyList, boolean[] isVisited, int src, int cur, int count String path) {  
	  
	    //base case  
	    if(count == isVisited.length) {  
	  
	        /// last node has neighbour of first node. so it is a hamiltonian cycle  
	        for(var each : adjacencyList[cur]){  
	            if(src == each.neighbour){  
	                HamiltonianCycle++;  
	                Println("Hamiltonian Cycle: "+ path);  
	                return;  
	            }  
	        }  
	  
	        // else it is hamiltonian path  
	        HamiltonianPath++;  
	        Println("Hamiltonian Path: "+ path);  
	  
	        return;  
	    }  
	  
	    for(var each : adjacencyList[cur]){  
	        if(isVisited[each.neighbour] == false){  
	            isVisited[each.neighbour] = true;  
	            HamiltonPath(adjacencyList, isVisited, src, each.neighbour, count+1  path +" "+each.neighbour);  
	            isVisited[each.neighbour] = false;  
	        }  
	    }  
	  
	}  
	  
	public static void main(String[] args) throws Exception {  
	    BufferedReader bfr = new BufferedReader(new InputStreamReader(System.in));  
	    int vertices = Integer.parseInt(bfr.readLine().trim());  
	  
	    ArrayList<Edge>[] adjacencyList = new ArrayList[vertices];  
	    for(int i = 0; i < adjacencyList.length; i++){  
	        adjacencyList[i] = new ArrayList<Edge>();  
	    }  
	  
	    int edges = Integer.parseInt(bfr.readLine());  
	    for(int i = 0; i < edges; i++){  
	        String[] str = bfr.readLine().split(" ");  
	        int v1 = Integer.parseInt(str[0]);  
	        int v2 = Integer.parseInt(str[1]);  
	        int wght = Integer.parseInt(str[2]);  
	  
	        adjacencyList[v1].add( new Edge(v1, v2, wght));  
	        adjacencyList[v2].add( new Edge(v2, v1, wght));  
	    }  
	  
	    boolean[] isVisited = new boolean[vertices];  
	  
	    for(int i = 0; i < vertices; i++ ){  
	        isVisited[i] = true;  
	        HamiltonPath(adjacencyList, isVisited, i, i, 1, i+""); 
	        isVisited[i] = false;  
	    }  
	  
	    Println("No of Hamiltonian Path: "+ HamiltonianPath);  
	    Println("No of Hamiltonian Cycle: "+ HamiltonianCycle);  
	}
	
	public static void Println(String str) {  
		System.out.println(str);  
	}  
	public static void Print(String str) {  
		System.out.print(str);  
	}  
}
```