# **2️⃣ HashSet Approach**
```java
	HashSet<Integer> visited = new HashSet<>();
```

- **Advantages**:
    
    1. Node index 0..n-1 হতে হবে না, dynamic keys possible
        
    2. Code sometimes cleaner (add/remove instead of boolean array)
        
    3. Base case: `visited.size() == vertices` → O(1)
        
- **Disadvantages**:
    
    1. O(1) average, কিন্তু HashSet operations কিছু overhead রাখে → boolean array-এর চেয়ে একটু slower
        
    2. Extra memory overhead (HashSet object + hashing)
        
    3. Frequent add/remove recursion এ impact হতে পারে

```java title:"Hamiltonian Path and Cycle"
public class Edge {  
    int source;  
    int neighbour;  
    int weight;  
  
    public Edge(int source, int neighbour, int weight){  
        this.source = source;  
        this.neighbour = neighbour;  
        this.weight = weight;  
    }  
}

public class Main {  
	public static int HamiltonianPath = 0;  
	public static int HamiltonianCycle = 0;  
	  
	public static void ConnectedComponents(ArrayList<Edge>[] adjacencyList, HashSet<Integer> isVisited, int src, int cur, int count, String path) {  
  
    //base case  
    if(adjacencyList.length == isVisited.size()) {  
  
        /// last node has neighbour of first node. so it is a hamiltonian cycle  
        for(var each : adjacencyList[cur]){  
            if(src == each.neighbour){  
                HamiltonianCycle++;  
                Println("Hamiltonian Cycle: "+ path);  
                return;  
            }  
        }  
  
        // else it is hamiltonian path  
        HamiltonianPath++;  
        Println("Hamiltonian Path: "+ path);  
  
        return;  
    }  
  
    for(var each : adjacencyList[cur]){  
        if(!isVisited.contains(each.neighbour)){  
            isVisited.add(each.neighbour);  
            ConnectedComponents(adjacencyList, isVisited, src, each.neighbour, count+1, path +" "+each.neighbour);  
            isVisited.remove(each.neighbour);  
        }  
    }  
  
}  
  
	public static void main(String[] args) throws Exception {  
	    BufferedReader bfr = new BufferedReader(new InputStreamReader(System.in));  
	    int vertices = Integer.parseInt(bfr.readLine().trim());  
	  
	    ArrayList<Edge>[] adjacencyList = new ArrayList[vertices];  
	    for(int i = 0; i < adjacencyList.length; i++){  
	        adjacencyList[i] = new ArrayList<Edge>();  
	    }  
	  
	    int edges = Integer.parseInt(bfr.readLine());  
	    for(int i = 0; i < edges; i++){  
	        String[] str = bfr.readLine().split(" ");  
	        int v1 = Integer.parseInt(str[0]);  
	        int v2 = Integer.parseInt(str[1]);  
	        int wght = Integer.parseInt(str[2]);  
	  
	        adjacencyList[v1].add( new Edge(v1, v2, wght));  
	        adjacencyList[v2].add( new Edge(v2, v1, wght));  
	    }  
	  
	    //boolean[] isVisited = new boolean[vertices];  
	    HashSet<Integer> isVisited = new HashSet<>();  
	  
	    for(int i = 0; i < vertices; i++ ){  
	        isVisited.add(i);  
	        ConnectedComponents(adjacencyList, isVisited, i, i, 1, i+"");  
	        isVisited.remove(i);  
	    }  
	  
	    Println("No of Hamiltonian Path: "+ HamiltonianPath);  
	    Println("No of Hamiltonian Cycle: "+ HamiltonianCycle);  
	}
	
	public static void Println(String str) {  
		System.out.println(str);  
	}  
	public static void Print(String str) {  
		System.out.print(str);  
	}  
}
```

