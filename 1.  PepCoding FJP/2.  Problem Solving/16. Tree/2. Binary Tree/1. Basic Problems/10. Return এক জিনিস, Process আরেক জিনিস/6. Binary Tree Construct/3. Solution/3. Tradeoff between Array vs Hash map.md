## ЁЯФ╖ Problem Context:

LeetCode 105 ржП ржмрж▓рж╛ ржЖржЫрзЗ тАФ

> Array size тЙд 3000  
> Elements range: **[-3000, 3000]**

ржорж╛ржирзЗ:

- ржорзЛржЯ element рж╕ржВржЦрзНржпрж╛: рж╕рж░рзНржмрзЛржЪрзНржЪ 3000
    
- ржХрж┐ржирзНрждрзБ **value range** рж╣рж▓рзЛ negative ржерзЗржХрзЗ positive ржкрж░рзНржпржирзНрждред
    

---

## тЭУ рждрж╛рж╣рж▓рзЗ ржкрзНрж░рж╢рзНржи:

ржЖржорж░рж╛ рждрзЛ inorder array-рждрзЗ ржХрзЛржирзЛ value ржПрж░ position ржЦрзБржБржЬрждрзЗ ржЪрж╛ржЗ (ржпрж╛рждрзЗ split ржХрж░рж╛ ржпрж╛рзЯ)ред  
рждрж╛рж╣рж▓рзЗ ржХрзЗржи **HashMap** ржмрзНржпржмрж╣рж╛рж░ ржХрж░ржм?

---

## ЁЯФН Step-by-step Logic:

### тЬЕ 1я╕ПтГг Inorder array рждрзЗ ржкрзНрж░рждрж┐ржЯрж┐ element unique

рждрж╛рж╣рж▓рзЗ ржЖржорж░рж╛ ржпржжрж┐ **inorder array рждрзЗ value тЖТ index mapping** ржЖржЧрзЗ ржерзЗржХрзЗржЗ store ржХрж░рзЗ рж░рж╛ржЦрж┐,  
рждрж╛рж╣рж▓рзЗ ржкрзНрж░рждрж┐ржмрж╛рж░ binary search ржирж╛ ржХрж░рзЗ **O(1)** time ржП index ржкрзЗрзЯрзЗ ржпрж╛ржмред

---

### тЬЕ 2я╕ПтГг HashMap ржПрж░ ржкрзНрж░рзЯрзЛржЬржирзАрзЯрждрж╛:

рждрзБржорж┐ ржарж┐ржХржЗ ржмрж▓рзЗржЫрзЛ тАФ  
ржпржжрж┐ values рж╕ржм positive ржПржмржВ ржЫрзЛржЯ range ржПрж░ рж╣рждрзЛ (ржпрзЗржоржи 0 ржерзЗржХрзЗ 3000 ржкрж░рзНржпржирзНржд),  
рждрж╛рж╣рж▓рзЗ ржЖржорж░рж╛ ржЪрж╛ржЗрж▓рзЗ simple **array-based lookup** ржХрж░рждрзЗ ржкрж╛рж░рждрж╛ржо, ржпрзЗржоржи:

```java
int[] pos = new int[3001]; // direct indexing possible

```
ржХрж┐ржирзНрждрзБ...

---

### тЪая╕П 3я╕ПтГг Problem: Value range тЖТ -3000 to +3000

ржПржЦржи, negative value ржЧрзБрж▓рзЛ рждрзЛ array index рж╣рж┐рж╕рзЗржмрзЗ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж╛ ржпрж╛ржмрзЗ ржирж╛ред  
ржХрж╛рж░ржг Java рждрзЗ array index рж╕ржмрж╕ржорзЯ 0 ржмрж╛ рждрж╛рж░ ржЙржкрж░рзЗ рж╣рзЯред

рждрзБржорж┐ ржнрж╛ржмрждрзЗ ржкрж╛рж░рзЛ offset ржпрзЛржЧ ржХрж░рзЗ ржПржЯрж╛рж░ рж╕ржорж╛ржзрж╛ржи ржХрж░рж╛ ржпрж╛рзЯ:

```java 
	int offset = 3000;
	int[] pos = new int[6001];
	
	pos[value + offset] = index;
```

ржПржЯрж╛ theoretically possible тЬЕ  
ржХрж┐ржирзНрждрзБ practically тАФ ржПржЯрж╛ clean, readable, maintainable ржирж╛ тЭМ

---

### тЬЕ 4я╕ПтГг рждрж╛ржЗ Hash-Map is the better choice:

```java 
	Map<Integer, Integer> inorderMap = new HashMap<>();
	for (int i = 0; i < inorder.length; i++)
	{     
		 inorderMap.put(inorder[i], i);
	}
```

ржПржЦржи lookup рж╣ржмрзЗ:

```java
	int idx = inorderMap.get(rootValue);
```

ржПрж░ time complexity **O(1)** (average),  
ржЖрж░ readability ржПржмржВ code maintainability ржЕржирзЗржХ ржнрж╛рж▓рзЛред

---

### ЁЯФЪ 5я╕ПтГг Summary Table:

|Approach|Handle Negative?|Lookup Speed|Space|Readability|Use Case|
|---|---|---|---|---|---|
|Direct Array Index|тЭМ No|тЬЕ O(1)|Moderate|тЭМ Poor|Only positive range|
|Offset Array|тЬЕ Yes|тЬЕ O(1)|High|тЪая╕П Confusing|Rare use|
|**HashMap**|тЬЕ Yes|тЬЕ O(1)**|Moderate|тЬЕ Clean|тЬЕ Best Choice|
