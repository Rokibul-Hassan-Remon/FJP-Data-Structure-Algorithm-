## ЁЯза Note: Understanding the Boundary Check Logic

ржЖржорж┐ рж╢рзБрж░рзБрждрзЗ `start < 0` ржмрж╛ `end >= inorder.length` ржЪрзЗржХржЯрж╛ ржжрж┐рзЯрзЗржЫрж┐рж▓рж╛ржо ржХрж╛рж░ржг ржЖржорж╛рж░ ржоржирзЗ рж╣рзЯрзЗржЫрж┐рж▓,  
recursive call ржЪрж▓рж╛рж░ рж╕ржорзЯ index boundary-рж░ ржмрж╛ржЗрж░рзЗ ржЪрж▓рзЗ ржпрзЗрждрзЗ ржкрж╛рж░рзЗ тАФ  
ржорж╛ржирзЗ ржнрзБрж▓ржХрзНрж░ржорзЗ negative index ржмрж╛ array length cross ржХрж░рзЗ ржлрзЗрж▓рждрзЗ ржкрж╛рж░рзЗред  
рждрж╛ржЗ ржЖржорж┐ ржПржХрзЗ **defensive programming** ржнрзЗржмрзЗ extra check ржпрзЛржЧ ржХрж░рзЗржЫрж┐рж▓рж╛ржоред

ржХрж┐ржирзНрждрзБ ржкрж░рзЗ ржмрзБржЭрзЗржЫрж┐,  
ржЖржорж╛ржжрзЗрж░ base condition `start > end` ржПржоржиржнрж╛ржмрзЗ ржХрж╛ржЬ ржХрж░рзЗ  
ржпрзЗ ржПржЗ boundary case **naturally handle** рж╣рзЯрзЗ ржпрж╛рзЯред  
ржлрж▓рзЗ recursion ржХржЦржиржУ 0-ржПрж░ ржирж┐ржЪрзЗ ржмрж╛ array length-ржПрж░ ржмрж╛ржЗрж░рзЗ ржпрж╛ржмрзЗ ржирж╛ред

---

### ЁЯФ╣ Intuition Link with Binary Search

ржПржЗ condition (`start > end`) ржЖрж╕рж▓рзЗ **Binary Search** logic-ржПрж░ ржорждрзЛржЗ тАФ  
ржпрзЗржЦрж╛ржирзЗ ржЖржорж░рж╛ **search ржмржирзНржз ржХрж░рж┐ ржпржЦржи search space ржлрзБрж░рж┐рзЯрзЗ ржпрж╛рзЯ**ред  
рждрж╛ржЗ ржарж┐ржХ ржпрзЗржнрж╛ржмрзЗ binary search-ржП extra `start < 0` ржмрж╛ `end >= n` ржЪрзЗржХ ржжрж┐ржЗ ржирж╛,  
ржПржЦрж╛ржирзЗржУ рждрзЗржоржи ржЪрзЗржХ ржжрзЗржУрзЯрж╛рж░ ржжрж░ржХрж╛рж░ рж╣рзЯ ржирж╛ред

---

### ЁЯТб Insight: Why the Same Idea Works

Binary Search ржЖрж░ Tree Construction тАФ ржжрзБржЯрзЛржЗ **Divide and Conquer** pattern-ржПрж░ ржЙржжрж╛рж╣рж░ржгред

- ЁЯФ╕ Binary Search тАЬdivide ржХрж░рзЗ ржПржХржЯрж╛ half discard ржХрж░рзЗредтАЭ
    
- ЁЯФ╕ Tree Construction тАЬdivide ржХрж░рзЗ ржжрзБржЗ half ржерзЗржХрзЗржЗ recursive ржнрж╛ржмрзЗ subtree ржмрж╛ржирж╛рзЯредтАЭ
    

рждрж╛ржЗ middle calculation, boundary handling, ржПржмржВ termination condition тАФ  
ржжрзБржЯрзЛ ржХрзНрж╖рзЗрждрзНрж░рзЗржЗ **ржПржХржЗ conceptual base**-ржПрж░ ржЙржкрж░ ржжрж╛ржБрзЬрж┐рзЯрзЗ ржЖржЫрзЗред