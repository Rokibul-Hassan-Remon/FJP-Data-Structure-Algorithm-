## ЁЯзй Problem Setup:

рждрзЛржорж╛ржХрзЗ ржПржХржЯрж╛ **inorder traversal list** ржжрзЗржУрзЯрж╛ ржЖржЫрзЗ  
ржпрзЗржоржи ЁЯСЙ `[1, 2, 3, 4, 5, 6, 7]`

ржПржЦржи рждрзБржорж┐ ржЬрж╛ржирзЛ тАФ  
**Inorder traversal of BST = Sorted (increasing) order.**

рждрж╛рж╣рж▓рзЗ naturally ржПржЗ array-ржЯрж╛ ржПржХржЯрж╛ BST-ржПрж░ inorder рж╣рждрзЗ ржкрж╛рж░рзЗред

---

## ЁЯОп Task:

рждрзБржорж┐ ржПржЗ array ржерзЗржХрзЗ ржПржХржЯрж╛ **Balanced BST** ржмрж╛ржирж╛рждрзЗ ржЪрж╛ржУ  
(ржирж╛ рж╣рж▓рзЗ ржПржЯрж╛ ржПржХржкрж╛рж╢рзЗ рж╣рзЗрж▓рзЗ ржкрзЬржмрзЗ тАФ ржпрзЗржоржи рж╕ржм element ржбрж╛ржи ржжрж┐ржХрзЗ ржЧрзЗрж▓рзЗ LinkedList рж╣рзЯрзЗ ржпрж╛ржмрзЗ)

---

## ЁЯФН High-level Observation:

BST ржПрж░ definition ржЕржирзБржпрж╛рзЯрзА:

- Left subtree < Root < Right subtree
    
- ржПржмржВ inorder traversal ржПржЗ ржХрзНрж░ржорзЗржЗ рж╕рж╛ржЬрж╛ржирзЛ ржерж╛ржХрзЗред
    

рждрж╛рж╣рж▓рзЗ ржПржЗ sorted array ржПрж░ ржорж╛ржЭрзЗрж░ element рж╣ржмрзЗ **root** тЬЕ  
ржХрж╛рж░ржг ржПрж░ ржмрж╛ржо ржжрж┐ржХрзЗрж░ рж╕ржм ржЫрзЛржЯ тАФ ржпрж╛ржмрзЗ **left subtree рждрзЗ**,  
ржЖрж░ ржбрж╛ржи ржжрж┐ржХрзЗрж░ рж╕ржм ржмрзЬ тАФ ржпрж╛ржмрзЗ **right subtree рждрзЗ**ред

---

## ЁЯза High-level Algorithm Thinking (Step by Step)

### Step 1я╕ПтГг:

Find middle element тЖТ make it **root**  
ЁЯСЙ middle = `(start + end) / 2`

### Step 2я╕ПтГг:

Left part тЖТ recursively build left subtree  
Right part тЖТ recursively build right subtree

### Step 3я╕ПтГг:

Base case тЖТ ржпржЦржи start > end, рждржЦржи `null` return ржХрж░ржмрзЗред

---

## ЁЯзй Example Visualization:
```java 
	Inorder list = [1, 2, 3, 4, 5, 6, 7]
	
	Middle = 4 тЖТ Root = 4
	Left = [1, 2, 3] тЖТ Left Subtree
	Right = [5, 6, 7] тЖТ Right Subtree

```

```txt
        4
       / \
      2   6
     / \ / \
    1  3 5  7

```

## тЪЩя╕П Time Complexity:

ржкрзНрж░рждрж┐ржЯрж┐ element ржПржХржмрж╛рж░ visit рж╣рзЯ тЗТ **O(n)**  
Space Complexity (recursion stack): **O(log n)** (balanced case)

---

## ЁЯзй Real Insight тАФ Why Middle?

ржПржЗржЯрж╛ pure **Divide & Conquer** logic:  
ржЖржорж░рж╛ ржкрзБрж░рзЛ sorted list ржХрзЗ ржорж╛ржЭржЦрж╛ржи ржерзЗржХрзЗ ржнрж╛ржЧ ржХрж░рзЗ  
ржкрзНрж░рждрж┐ржмрж╛рж░ тАЬroot-centerтАЭ concept ржП tree ржмрж╛ржирж╛ржЪрзНржЫрж┐ред

ржПржнрж╛ржмрзЗ height balanced BST рждрзИрж░рж┐ рж╣рзЯред  
ржПржЗ pattern ржЯрж╛ later **AVL Tree** ржПржмржВ **Segment Tree** рждрзЗ base logic рж╣рж┐рж╕рзЗржмрзЗ ржмрзНржпржмрж╣рж╛рж░ рж╣рзЯред

---

## ЁЯТб Summary:

|Concept|Idea|
|---|---|
|Input|Sorted inorder list|
|Output|Balanced BST|
|Approach|Divide & Conquer|
|Key Step|Pick middle as root|
|Complexity|O(n)|
|Recursion Base Case|start > end тЖТ null|
ЁЯСЙ `mid = (start + end) / 2`  
ржПржЗ **same logic**-ржЯрж╛ржЗ binary search ржП ржпрзЗржоржи ржмрзНржпржмрж╣рж╛рж░ рж╣рзЯ, **ржПржЦрж╛ржирзЗржУ ржарж┐ржХ рждрзЗржоржиржнрж╛ржмрзЗржЗ ржмрзНржпржмрж╣рж╛рж░ ржХрж░ржм**ред

---

### ЁЯза ржХрж╛рж░ржгржЯрж╛ ржмрзЛржЭрзЛ тАФ

Binary search ржП ржЖржорж░рж╛ ржорж╛ржЭрзЗрж░ element ржирж┐ржЗ ржХрж╛рж░ржг тАФ  
ржУржЗ element ржЯрж╛ тАЬpartition pointтАЭ рж╣рж┐рж╕рзЗржмрзЗ ржХрж╛ржЬ ржХрж░рзЗ,  
ржорж╛ржирзЗ, рждрж╛рж░ ржмрж╛ржорзЗ ржЫрзЛржЯржЧрзБрж▓рзЛ, ржЖрж░ рждрж╛рж░ ржбрж╛ржирзЗ ржмрзЬржЧрзБрж▓рзЛ ржерж╛ржХрзЗред

**ржарж┐ржХ ржПржХржЗ ржЬрж┐ржирж┐рж╕ ржПржЦрж╛ржирзЗ ржШржЯржЫрзЗ:**

- ржЖржорж╛ржжрзЗрж░ inorder list ржЖржЧрзЗржЗ sorted тЬЕ
    
- ржПржЦржи ржорж╛ржЭрзЗрж░ element рж╣ржмрзЗ BST-ржПрж░ **root**
    
- ржХрж╛рж░ржг рждрж╛рж░ ржмрж╛ржорзЗ ржпржд element ржЖржЫрзЗ, рж╕ржм ржЫрзЛржЯ  
    (so рждрж╛рж░рж╛ left subtree рждрзЗ ржпрж╛ржмрзЗ)
    
- ржЖрж░ ржбрж╛ржирзЗ ржпржд element ржЖржЫрзЗ, рж╕ржм ржмрзЬ  
    (so рждрж╛рж░рж╛ right subtree рждрзЗ ржпрж╛ржмрзЗ)
    

---

### ЁЯУК рждрзБрж▓ржирж╛ ржХрж░рж▓рзЗ ржжрзЗржЦрж╛ ржпрж╛ржмрзЗ:

|Concept|Binary Search|BST Construct|
|---|---|---|
|Goal|ржЦрзЛржБржЬрж╛|Tree ржмрж╛ржирж╛ржирзЛ|
|Middle|`mid = (l + r) / 2`|`mid = (s + e) / 2`|
|Left part|ржЫрзЛржЯ range ржП search|Left subtree ржмрж╛ржирж╛ржирзЛ|
|Right part|ржмрзЬ range ржП search|Right subtree ржмрж╛ржирж╛ржирзЛ|
|Common Logic|Divide by middle|Divide by middle|

---

### тЪЩя╕П ржЫрзЛржЯ Technical Note:

ржпржжрж┐ рждрзБржорж┐ overflow-safe version рж▓рж┐ржЦрждрзЗ ржЪрж╛ржУ (ржпрзЗржоржи Leetcode style):

```java 
	int mid = start + (end - start) / 2;
```

ржХрж╛рж░ржг `(start + end)` ржмрзЬ рж╣рж▓рзЗ integer overflow рж╣рждрзЗ ржкрж╛рж░рзЗред

---

рждрж╛рж╣рж▓рзЗ рж╣рзНржпрж╛ржБ ЁЯСН  
тЮб **ржПржЗ binary search ржПрж░ midpoint formula ржЯрж╛ржХрзЗржЗ ржПржЦрж╛ржирзЗ ржмрзНржпржмрж╣рж╛рж░ ржХрж░ржмрзЗ**,  
рж╢рзБржзрзБ ржЙржжрзНржжрзЗрж╢рзНржп ржЖрж▓рж╛ржжрж╛ тАФ  
binary search ржП ржЖржорж░рж╛ ржЦрзБржБржЬрзЗ ржкрж╛ржЗ,  
ржЖрж░ ржПржЦрж╛ржирзЗ ржЖржорж░рж╛ tree рждрзИрж░рж┐ ржХрж░рж┐ред ЁЯМ▒