# ðŸŒ³ Tree Traversal & Node Modification â€“ Case Study Notes

---
## **Case Study 1: Printing nodes in tree**

**Scenario:**

-` Pre-order`, `In-order`, `Post-order` traversal à¦ nodes print à¦•à¦°à¦¾à¥¤
    

**Problem arises?**

- à¦†à¦¸à¦²à§‡ à¦•à¦¿à¦›à§ problem à¦¨à§‡à¦‡à¥¤ Printing à¦•à¦°à¦²à§‡ tree structure à¦ªà¦°à¦¿à¦¬à¦°à§à¦¤à¦¿à¦¤ à¦¹à§Ÿ à¦¨à¦¾à¥¤
    

**Why safe?**

- Printing = read-only operation
    
- Recursion & traversal order unaffected
    

**Solution / How to do?**

- à¦¯à§‡à¦•à§‹à¦¨à§‹ traversal order safe: pre/in/post
    

**When / Which approach?**

|Operation type|Safe order to use|
|---|---|
|Print / Read-only|Pre, In, Post â€“ All safe|
|Value modification|Pre, In, Post â€“ All safe|

---

## **Case Study 2: Pointer / Structure Modification**

**Scenario:**

- Tree à¦à¦° node restructure à¦•à¦°à¦¾, à¦¯à§‡à¦®à¦¨: left clone remove à¦•à¦°à¦¾, child pointer change à¦•à¦°à¦¾
    

**Problem arises:**

- à¦¯à¦¦à¦¿ **pre-order style** (modify â†’ recursively ) à¦¬à§à¦¯à¦¬à¦¹à¦¾à¦° à¦•à¦°à¦¾ à¦¹à§Ÿ:
    
    - Subtree skip à¦¹à§Ÿà§‡ à¦¯à¦¾à¦¬à§‡
        
    - Recursion à¦­à§à¦² node à¦ à¦¯à¦¾à¦¬à§‡
        
    - Result corrupted à¦¹à¦¬à§‡

**Cause:**

- Node pointer modify à¦•à¦°à¦¾à¦° timing à¦à¦¬à¦‚ recursion order mismatch
    
- Traversal order break à¦¹à§Ÿà§‡ à¦¯à¦¾à§Ÿ

**Solution / How to overcome:**

- **Post-order recursion:**
    
    1. Recurse left subtree
        
    2. Recurse right subtree
        
    3. Modify current node pointers
        
- à¦à¦­à¦¾à¦¬à§‡ recursion à¦¶à§‡à¦· à¦¹à§Ÿà§‡ à¦¯à¦¾à¦¬à§‡ subtree à¦¤à§‡ â†’ parent safely modify à¦•à¦°à¦¾ à¦¯à¦¾à¦¬à§‡

**Example:**
```java 
void removeClone(BinaryTree node) {
    if(node == null) return;
    removeClone(node.left);
    removeClone(node.right);
    if(node.left != null)
        node.left = node.left.left;
}

```

**When / Which approach?**

|Operation type|Safe order|
|---|---|
|Structural pointer change|Post-order|
|Insert / Delete / Rewire|Post-order|
|Only value change|Any order|

---

## **Case Study 3: Left-Cloned Tree Transformation**

**Scenario:**

- Transform original tree â†’ Left-Cloned tree

**Problem arises:**

- à¦¯à¦¦à¦¿ only `left != null` à¦ clone attach à¦•à¦°à¦¾ à¦¹à§Ÿ â†’ leaf nodes clone à¦¹à¦¬à§‡ à¦¨à¦¾ â†’ output incomplete

**Cause:**

- Pre-order recursion + conditional clone â†’ some nodes skipped

**Solution / How to overcome:**

- Use **post-order recursive approach**
    
- Clone attach à¦•à¦°à¦¤à§‡ à¦¹à¦¬à§‡:
    
    1. Traverse left subtree â†’ get processed left
        
    2. Traverse right subtree
        
    3. Attach clone at current node
        
- Leaf nodes à¦à¦¬à¦‚ left/right subtree à¦¸à¦¬ cover à¦¹à¦¬à§‡

**Example:**
```java 
	BinaryTree transformToLeftClone(BinaryTree node) {
	    if(node == null) 
		    return null;
		    
	    BinaryTree lcl = transformToLeftClone(node.left);
	    BinaryTree rcl = transformToLeftClone(node.right);
	    
	    BinaryTree clone = new BinaryTree(node.data, lcl, null);
	    node.left = clone;
	    node.right = rcl;
	    
	    return node;
	}
```

---
## **Guidelines / Key Takeaways**

1. **recursion order flexible** -> `Printing or Value modification`
    
2. **post-order recommended**  â†’ `Structural modification (pointer change, insert, delete, rewire)`
    
3. **recursion timing + pointer modify timing** = `Traversal order matters` 
    
4. **General principle:**
    
    - Always ensure **subtrees are fully traversed** before modifying parent pointers
        
    - Otherwise, **subtree nodes** may skip â†’` logical bug`

