# 🌳 Tree Traversal & Node Modification – Case Study Notes

---
## **Case Study 1: Printing nodes in tree**

**Scenario:**

-` Pre-order`, `In-order`, `Post-order` traversal এ nodes print করা।
    

**Problem arises?**

- আসলে কিছু problem নেই। Printing করলে tree structure পরিবর্তিত হয় না।
    

**Why safe?**

- Printing = read-only operation
    
- Recursion & traversal order unaffected
    

**Solution / How to do?**

- যেকোনো traversal order safe: pre/in/post
    

**When / Which approach?**

|Operation type|Safe order to use|
|---|---|
|Print / Read-only|Pre, In, Post – All safe|
|Value modification|Pre, In, Post – All safe|

---

## **Case Study 2: Pointer / Structure Modification**

**Scenario:**

- Tree এর node restructure করা, যেমন: left clone remove করা, child pointer change করা
    

**Problem arises:**

- যদি **pre-order style** (modify → recursively ) ব্যবহার করা হয়:
    
    - Subtree skip হয়ে যাবে
        
    - Recursion ভুল node এ যাবে
        
    - Result corrupted হবে

**Cause:**

- Node pointer modify করার timing এবং recursion order mismatch
    
- Traversal order break হয়ে যায়

**Solution / How to overcome:**

- **Post-order recursion:**
    
    1. Recurse left subtree
        
    2. Recurse right subtree
        
    3. Modify current node pointers
        
- এভাবে recursion শেষ হয়ে যাবে subtree তে → parent safely modify করা যাবে

**Example:**
```java 
void removeClone(BinaryTree node) {
    if(node == null) return;
    removeClone(node.left);
    removeClone(node.right);
    if(node.left != null)
        node.left = node.left.left;
}

```

**When / Which approach?**

|Operation type|Safe order|
|---|---|
|Structural pointer change|Post-order|
|Insert / Delete / Rewire|Post-order|
|Only value change|Any order|

---

## **Case Study 3: Left-Cloned Tree Transformation**

**Scenario:**

- Transform original tree → Left-Cloned tree

**Problem arises:**

- যদি only `left != null` এ clone attach করা হয় → leaf nodes clone হবে না → output incomplete

**Cause:**

- Pre-order recursion + conditional clone → some nodes skipped

**Solution / How to overcome:**

- Use **post-order recursive approach**
    
- Clone attach করতে হবে:
    
    1. Traverse left subtree → get processed left
        
    2. Traverse right subtree
        
    3. Attach clone at current node
        
- Leaf nodes এবং left/right subtree সব cover হবে

**Example:**
```java 
	BinaryTree transformToLeftClone(BinaryTree node) {
	    if(node == null) 
		    return null;
		    
	    BinaryTree lcl = transformToLeftClone(node.left);
	    BinaryTree rcl = transformToLeftClone(node.right);
	    
	    BinaryTree clone = new BinaryTree(node.data, lcl, null);
	    node.left = clone;
	    node.right = rcl;
	    
	    return node;
	}
```

---
## **Guidelines / Key Takeaways**

1. **recursion order flexible** -> `Printing or Value modification`
    
2. **post-order recommended**  → `Structural modification (pointer change, insert, delete, rewire)`
    
3. **recursion timing + pointer modify timing** = `Traversal order matters` 
    
4. **General principle:**
    
    - Always ensure **subtrees are fully traversed** before modifying parent pointers
        
    - Otherwise, **subtree nodes** may skip →` logical bug`

